
package bcel

import java.util.Arrays
import java.util.regex.Pattern
import org.apache.bcel.Constants
import org.apache.bcel.Repository
import org.apache.bcel.classfile._
import org.apache.bcel.generic.ArrayType
import org.apache.bcel.generic.ObjectType
import org.apache.bcel.generic.Type
import org.apache.bcel.util.ClassQueue
import org.apache.bcel.util.ClassSet



class DepVisitor(clazz: JavaClass, repo: org.apache.bcel.util.Repository) extends org.apache.bcel.classfile.EmptyVisitor {
	//private var _queue = new ClassQueue
	//_queue.enqueue(clazz)
	
	private var _set = new ClassSet
	_set.add(clazz)
	def getClasses = _set.toArray
	def getClassNames = _set.getClassNames
	
	private var _cp: ConstantPool = null
	private var _ignored	= List("java[.].*", "javax[.].*", "sun[.].*", "sunw[.].*",
			"com[.]sun[.].*", "org[.]omg[.].*", "org[.]w3c[.].*", "org[.]xml[.].*", "net[.]jini[.].*" )
	def getIgnored = _ignored
	def setIgnored(v: Array[String] ) = _ignored = v.toList
	
	def  start = {
		//while (!_queue.empty()) {
			//val clazz = _queue.dequeue()
			val methods = clazz.getMethods.toList
			methods.foreach(m =>{ 
				m.getArgumentTypes.toList.foreach(t => checkType(t))
				checkType(m.getReturnType)
			})
			
			val fields = clazz.getFields.toList
			fields.foreach(f => checkType(f.getType))
		
			_cp = clazz.getConstantPool()
			new org.apache.bcel.classfile.DescendingVisitor(clazz, this).visit()
		//}
	}

	
	private def add( class_name: String) : Unit = {
		var classname = class_name.replace('/', '.')
		//println(classname + ": " +  _ignored)
		if ( class_name.startsWith("[") ) {
			val idx = classname.lastIndexOf("[")
			if ( classname(idx+1) != 'L' ) return
			classname = classname.substring(idx+2, classname.length - 1)
			//println("****" + classname)
		}
		if ( _ignored.exists(ign =>  (Pattern.matches(ign, classname) ) ) ) return

				
		try {
			val clazz = repo.loadClass(classname)
			_set.add(clazz)
			//if ( _set.add(clazz) ) _queue.enqueue(clazz)
		}
		catch {
			case e: ClassNotFoundException =>// throw new IllegalStateException("Missing class: " + classname + ": " +  e.toString())
				println("Missing: " + classname )
		}
	}
	
	override def visitConstantClass(cc: ConstantClass): Unit = {
		val class_name = cc.getConstantValue(_cp).asInstanceOf[String]
		add(class_name)
		
		//println("visit class: " + class_name)
	}
	
	private def checkType(typ: Type) = {
		var t = typ
		if (t.isInstanceOf[ArrayType]) 
			t = t.asInstanceOf[ArrayType].getBasicType
			
		if (t.isInstanceOf[ObjectType]) 
			add(t.asInstanceOf[ObjectType].getClassName)
		
		//println("visit ref: " + t)
	}
	
	private def visitRef(ccp: ConstantCP,  method: Boolean ) = {
		add(ccp.getClass(_cp)) //class_name
		val cnat = _cp.getConstant(ccp.getNameAndTypeIndex(),
				Constants.CONSTANT_NameAndType).asInstanceOf[ConstantNameAndType]
		val signature = cnat.getSignature(_cp)
		//println("visit ref signature: " + signature + " -- " + cnat.getName(_cp))
		if (method) {
			val t = Type.getReturnType(signature)
			checkType(t)
			val types = Type.getArgumentTypes(signature)
			types.foreach(t => checkType(t))
		} else {
			checkType(Type.getType(signature))
		}
	}

	override def visitConstantMethodref(cmr : ConstantMethodref ) = {
		visitRef(cmr, true)
	}

	override def visitConstantInterfaceMethodref(cimr : ConstantInterfaceMethodref ) =
		visitRef(cimr, true)

	override def visitConstantFieldref(cfr : ConstantFieldref ) = 
		visitRef(cfr, false)

}
