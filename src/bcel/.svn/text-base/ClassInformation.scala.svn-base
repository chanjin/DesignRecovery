package bcel

import org.apache.bcel._
import org.apache.bcel.classfile._
import java.io.File
import kr.ac.snu.selab.sepa._
import org.apache.bcel.generic.ArrayType
import org.apache.bcel.generic.ObjectType
import org.apache.bcel.generic.Type

object ClassInformation {
	private var repository: org.apache.bcel.util.Repository = null
	def setRepo(repo: org.apache.bcel.util.Repository ) = repository = repo
	
	def getOverridingMethods(cls: JavaClass, ancestor: JavaClass) = {
		def isNotConstrurctorNStatic(m: Method): Boolean = 
				!m.isStatic && (m.getName != "<init>")// init
		
		val ancestorMethods = ancestor.getMethods.toList
		cls.getMethods.toList.filter(m => (ancestorMethods.contains(m) && isNotConstrurctorNStatic(m))).map(_.getName)
	}
	
	
	def getDependentClasses(clazz: JavaClass): List[String] = {
		val depvisitor = new DepVisitor(clazz, repository)
		depvisitor.start
		/*if ( clazz.getClassName == "junit.samples.VectorTest")
			println("**********" + depvisitor.getClassNames.toList)*/
		depvisitor.getClassNames.toList.remove(_ == clazz.getClassName)
		/*val cpanalyzer = new ConstantPoolDependencySearch(clazz, repository)
		cpanalyzer.search()
		if ( clazz.getClassName == "junit.samples.VectorTest")
			println("**********" + cpanalyzer.getClassNames.toList)
			
		cpanalyzer.getClassNames.toList.remove(_ == clazz.getClassName)*/
	}
	 
	def getStructuralDependents(clazz: JavaClass) : List[String] = {
		var deps = List[String]()
		def checkType(typ: Type) = {
			var t = typ
			if (t.isInstanceOf[ArrayType]) 
				t = t.asInstanceOf[ArrayType].getBasicType
				
			if (t.isInstanceOf[ObjectType]) 
				deps = (t.asInstanceOf[ObjectType].getClassName) :: deps
		}
		
		deps = getAncestors(clazz).map(_.getClassName) :::  deps
		clazz.getMethods.toList.foreach(m =>{ 
			m.getArgumentTypes.toList.foreach(t => checkType(t))
			checkType(m.getReturnType)
		})

		clazz.getFields.toList.foreach(f => checkType(f.getType))
		deps
	}
	
	def getCodeDependentsOnly(clazz: JavaClass) : List[String] = {
		val structuraldeps = getStructuralDependents(clazz)
		getDependentClasses(clazz).remove(c => structuraldeps.contains(c))
	}
	
	def getSuperClass(clazz: JavaClass) : JavaClass = {
		var parents = List[JavaClass]()
		try {
			clazz.getSuperClass
		}
		catch {
			case ex: ClassNotFoundException => println("In " + clazz.getClassName + ": " + ex); null
		}
	}
	
	def getInterfaces(clazz: JavaClass) : List[JavaClass] = {
		val _interfaces = clazz.getInterfaceNames.toList
		var classes = List[JavaClass] ()
		for ( intf <- _interfaces) {
			try {
				val cls = repository.loadClass(intf)
				if ( cls != null ) classes = cls  :: classes
			}
			catch {
				case ex: ClassNotFoundException => println("In " + clazz.getClassName + ": " + ex); null
			}
		}
		classes
	}
	
	
	def getAncestors(clazz: JavaClass) : List[JavaClass]= {
		var ancestors = List[JavaClass] ()
		var cls = clazz
		while ( cls != null ) {
			cls = getSuperClass(cls)
			if ( cls != null ) ancestors = cls :: ancestors
		}
		var queue = new org.apache.bcel.util.ClassQueue()

		queue.enqueue(clazz)
		while (!queue.empty) {
			cls = queue.dequeue
			val souper = getSuperClass(cls)
			val _interfaces = getInterfaces(cls)
			if (cls.isInterface()) 
				ancestors = cls :: ancestors
			else  if (souper != null) 	queue.enqueue(souper)
			_interfaces.foreach(queue.enqueue(_))
		}
		
		ancestors.remove(_ == clazz)
	}
		
}