
import scala.io.Source._
import scala.xml.{Node, XML}

object MyClassXMLLoader extends Application {
  
  	var tdg = new TypeDependencyGraph
            
	val xmldata = XML.loadFile("types.sepa")
	val it = xmldata.child.elements
	while (it.hasNext) {
	  val node: Node = it.next
	 
	  if ( node.label == "types") {
	     Console.println(node.label)
	     makeTDG(node)
	  }
	  
	  if ( node.label == "packages" ) {
	      makePDG(node)
	  }
	}
 

	
	def xmlattr(n: Option[Seq[scala.xml.Node]]) = n match {
	    case Some(s) => s.text
	    case _ => "?"
	}
	
	def makeTypeGraph(node: scala.xml.Node)  = node match {
	  	case <type>{ info @ _* }</type> => tdg.addnode(xmlattr(node.attribute("qn")))
	  	    // "Type QN: " + node.attribute("qn") + ", ID:" + node.attribute("id")
		case <use>{ info @ _* }</use> => tdg.addsimpleedge(xmlattr(node.attribute("from")), xmlattr(node.attribute("to")))
		    // "Use: " + node.attribute("from") + "->" + node.attribute("to")
		case <subtype>{info @ _* }</subtype> => tdg.addsubtypeedge(xmlattr(node.attribute("from")), xmlattr(node.attribute("to")), "-")
		    // "Subtype: " + node.attribute("from") + "->" + node.attribute("to")
		case  _ =>
	}
	
	def makePackageGraph(node: scala.xml.Node) : String = {
	  	if ( node.label != "package" )  ""
	  	else {
	  	  val pkg = "Package QN: " + node.attribute("qn")
	  	  val it = node.child.elements
	  	  var typelist = List[String]()
	  	  while ( it.hasNext ) {
	  	      val n = it.next
	  	      if (n.label == "type") typelist = ("\n\t Type QN: " + n.attribute("idref")) :: typelist
	  	  }
	  	  pkg + typelist
	  	}
	}
 
 	def makeTDG(node: scala.xml.Node) = {
 		val it =node.child.elements
 		while ( it.hasNext ) {
 		  val n = it.next
 		  Console.print(n)
 		  makeTypeGraph(n)
 		  Console.println("*")
 		}
 		Console.println(tdg)
 	}
 	
 	 def makePDG(node: scala.xml.Node) = {
 		val it =node.child.elements
 		while ( it.hasNext ) {
 		  val n = it.next
 		  Console.println(makePackageGraph(n))
 		}
 	}
}



/// module edges
	
	private def getModuleEdges(esstr: List[(String, String)], ms: ModuleStructure) : List[ModuleEdge] = {
		var edges: List[ModuleEdge] = Nil
		for ( estr <- esstr ) {
			if ( ms.nodes.contains(estr._1) ) {
				val fromn = ms.nodes(estr._1)
				val edge =  fromn.outedges.find(_.getTarget.value == estr._2).getOrElse(null)
				if ( edge != null ) edges = edge.asInstanceOf[ModuleEdge] :: edges
			}
			else println("not found (from) : " + estr._1)
		}
		println("VVVVV" + edges)
		edges
	}
	
/*	private def getModuleNodes(ns: List[String], ms: LayeredPackageStructure) : List[LayerModuleNode] = {
		def nscontains(m: NodeElem): Boolean = ns.contains(m.asInstanceOf[LayerModuleNode].pkgname)
		ms.nodes.values.toList.filter(nscontains(_)).map(_.asInstanceOf[LayerModuleNode])
	}
	*/
	
	
	
	
package trace

import module._

class CallbackEdge(n1: NodeElem, n2: NodeElem, codeDep: Boolean) extends SimpleEdge(n1, n2, codeDep)  { }

class TypeStructureWithTrace(ts: TypeStructure, mcg: DependencyGraph, adhoc: List[String]) 
	extends TypeStructure {
	
	var mapT2M = Map[NodeElem, List[MethodData]]()
	//adhoc.foreach(clsname => addNode(clsname))
	mcg.nodes.values.foreach(n => {
		val clsname = n.asInstanceOf[MethodNode].getClassName
		val node = addNode(clsname)
		if ( !mapT2M.contains(node) ) mapT2M += (node -> List[MethodData]())
		mapT2M(node) = n :: mapT2M(node)
	})
	
	var mapTE2ME = Map[DepEdge, List[DepEdge]]()
	mcg.edges.foreach(e => {
		val source = e.getSource.asInstanceOf[MethodNode].getClassName
		val target = e.getTarget.asInstanceOf[MethodNode].getClassName
		
		var edge = getEdge(source,target) // already added
		if ( edge == null && source != target) {
			if ( ts.nodes.contains(source) && ts.nodes.contains(target) ) {
				var tedges = ts.nodes(source).outedges.filter(_.getTarget == ts.nodes(target))
				if ( tedges.length > 0 ) {
					assert(tedges.length == 1)
					edge = addSimpleEdge(source, target, true)
				}
				else { // tedges.length == 0
					println("Callback")
					tedges = ts.nodes(source).inedges.filter(_.getSource == ts.nodes(target))
					if ( tedges.length == 0 ) println("Oops! " + source + "->" + target + ": " +
							e.getSource.asInstanceOf[MethodNode].toName + " -> " + e.getTarget.asInstanceOf[MethodNode].toName)
					
					assert(tedges.length == 1)

					edge = addCallbackEdge(source, target, true)
					println("*** Callback Edge - " + edge)
				}
			}
			else 
				edge = addSimpleEdge(source, target, true)
		}
		
		if ( !mapTE2ME.contains(edge) ) mapTE2ME += (edge -> List[DepEdge]())
		mapTE2ME(edge) = e :: mapTE2ME(edge)
	})
	
	def addCallbackEdge(n1: String, n2: String, codeDep: Boolean) = {
		val e = new CallbackEdge(nodes(n1).asInstanceOf[TypeNode], nodes(n2).asInstanceOf[TypeNode], codeDep) 
		addEdge(e)
	}
}