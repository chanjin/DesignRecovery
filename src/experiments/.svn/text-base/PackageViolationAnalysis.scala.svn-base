package experiments
import module._
import experiments.investigation._


abstract class PackageViolationAnalysis {
	val project = projects.Project.proj 
	val prefix = project.prefix
		
	protected def getViolationMap: Map[String, List[String]]
	
	def getShortPackageName(pkg: String) = {
		 if (pkg.length > prefix.length) pkg.substring(prefix.length+1) else "."
	}
	
	def getLongPackageName(str: String) = {
		if (str == "." ) prefix else prefix + "." + str
	}
	
	def getViolations(pkg: String) : List[String] = {		
		val pkgname = getShortPackageName(pkg)
		
		if (getViolationMap.keys.toList.contains(pkgname) ) {
			getViolationMap(pkgname).map(str => getLongPackageName(str))
		}
		else
				List[String]()
	}
	
	
	def getNewPacakgeMap: Map[String, List[List[Int]]] = Map[String, List[List[Int]]]()
	def getRefactoredEdges: Map[(String, String), (List[Int], List[Int])]   = Map[(String, String), (List[Int], List[Int])]  ()
	
	def getDesignRuleClass() : List[String] = List[String]()
	
	
	
	def packageName(n: NodeElem) = n.asInstanceOf[LayerModuleNode].pkgname
	 
	def analysisViolations(lpdg: LayeredPackageStructure, pdg: PackageStructure, cycles: List[(NodeElem, List[NodeElem])]) : List[DepEdge]= {
		def getNodesInCycle(pkg: String, pkg2: String): List[NodeElem] = {
			val edges = lpdg.edges.filter(e => {
				val src = packageName(e.getSource)
				val dst = packageName(e.getTarget) 
				( src == pkg && dst == pkg2)  || ( src == pkg2 && dst == pkg)  
			})
			edges.foldLeft(List[NodeElem]())((ns, e) => e.getSource :: e.getTarget :: ns) //.filter(n => packages.contains(packageName(n)))
		}
		
		val lmi = new LayeredModuleInvestigator(lpdg)
		cycles.foreach(cycle => { 
			//println("***" + cycle)
			val pkg = cycle._1.value 
			//val packages = (cycle._1 :: cycle._2).map(_.value)
			val dotname = cycle._1.value.substring(prefix.length).replace(".", "_")
			
			cycle._2.foreach(p => {
				val pkg2 = p.value
				Graph2Dot.toDot(lpdg, 
						project.getHomePath + dotname +"_2_" + pkg2.substring(prefix.length).replace(".", "_") , 
						getNodesInCycle(pkg, pkg2))
			})
			
			
			Graph2Dot.toDot(pdg, project.getHomePath + dotname + "_pdg" , cycle._1 :: cycle._2)
			lmi.howLayered(pkg)
			lmi.howCoupled(pkg, pkg :: cycle._2.map(_.value), pdg)
		})
		
		var vedgesall = List[DepEdge]()
		cycles.foreach(cycle => {
			val pkg = cycle._1.value
			val vs: List[String] = getViolations(pkg)
			if ( vs.length > 0 ) {
				vs.foreach( pkg2 => { 
					val depedges =  lpdg.edges.filter(e => (packageName(e.getSource) == pkg && packageName(e.getTarget) == pkg2)).
							flatMap(e => e.asInstanceOf[ModuleEdge].getTypeEdges)
					vedgesall = depedges ::: vedgesall
					val tns = depedges.foldLeft(List[NodeElem]())((ns, e) => e.getSource :: e.getTarget :: ns)
					val dotname = pkg.substring(prefix.length).replace(".", "_") + "_2_" + pkg2.substring(prefix.length).replace(".", "_") + "_tdg"
					
					Graph2Dot.toDotType(lpdg.tdg, project.getHomePath + dotname, tns)	
				} )
				
			}
		})
		
		println("Violating edges: " + vedgesall.removeDuplicates.length)
		val vnodes = vedgesall.map(_.getTarget).removeDuplicates
		println("Violating nodes (targets): " + vnodes.length + "\n\t" + vnodes.mkString("\n\t"))
		vedgesall
	}
	
	def analysisPackages(pdg: PackageStructure): List[(NodeElem, List[NodeElem])] = {
		val nodes = pdg.nodes.values
		val edges = pdg.edges
		
		val cycles = nodes.map( n => (n, directCycles(n))).toList.filter(cycle => cycle._2.length > 0)
		println("--------------")
		println(cycles.map(n => n._1 + n._2.map(_.value.substring(prefix.length)).mkString("\n")))
		println("-------------- SCC ")
		
		cycles
	}
	
	
	protected def analysisSCC(lpdg: LayeredPackageStructure, pdg: PackageStructure, dotprefix: String) = { //: List[NodeElem] = {
		def getNodesInCycle(packages: List[String]): List[NodeElem] = {
			val edges = lpdg.edges.filter(e => {
				val src = packageName(e.getSource)
				val dst = packageName(e.getTarget) 
				packages.contains(src) && packages.contains(dst)  
			})
			edges.foldLeft(List[NodeElem]())((ns, e) => e.getSource :: e.getTarget :: ns) //.filter(n => packages.contains(packageName(n)))
		}
		
		val scc = pdg.detectSCC
		println(scc.mkString("\n"))
		scc.foreach( ms => {
			val packages = ms.map(_.value)
			val dotname1 = dotprefix + "SCC_" + packages.sort((m1, m2) => m1.toString.compareTo(m2.toString) < 0).map(str => str.substring(if ( str.contains(".") ) str.lastIndexOf(".") + 1 else 0)).mkString("_")
			val dotname = if (dotname1.length > 32) dotname1.substring(0, 32) + "___" else dotname1
			Graph2Dot.toDot(lpdg, project.getHomePath + dotname , getNodesInCycle(packages))
			Graph2Dot.toDot(pdg, project.getHomePath + dotname + "_pdg" , ms)
			
		})
	}
	
	
	def makeModuleStructures(tdg: TypeStructure,  dotprefix: String) = {
		val newpdg = new PackageStructure(tdg)
		tdg.nodes.values.foreach(node => { 
			val pkg = node.value.substring(0, node.value.lastIndexOf("."))
			newpdg.addTypeNode(newpdg.addNode(pkg), node.value)
		})
		newpdg.liftEdges
		
		val dotname = project.getHomePath + dotprefix
		Graph2Dot.toDot(newpdg.simplifyStructure,  dotname + "PDG_Rearchitected")
		Graph2Dot.toDot(newpdg, dotname + "PDG_Rearchitected_NoSimplification")
		
		val newlpdg = new LayeredPackageStructure(tdg)
		newlpdg.layeringPackages(newpdg)
		newlpdg.liftEdges()
		Graph2Dot.toDot(newlpdg, dotname + "LP_Rearchitected")

		val newclpdg = (new LayeredModuleIcebergs(newlpdg)).compact(tdg)
		Graph2Dot.toDot(newclpdg, dotname + "CLP_Rearchitected")
		
		analysisSCC(newclpdg, newpdg, dotprefix)
	}
	
	def analyzeDesignRuleEdges(tdg: TypeStructure, dredges: List[DepEdge]) : Unit = {
		val newtdg = tdg.makeNewTypeStructure(e => dredges.contains(e))
		println("=== " + tdg.edges.length +  " => " + newtdg.edges.length + " : " + (tdg.edges.length - newtdg.edges.length))
		makeModuleStructures(newtdg, "RuleEdge_")
	}
	
	def analyzeDesignRuleClasses(tdg: TypeStructure) : Unit = {
		val drclasses = getDesignRuleClass
		if (drclasses.length == 0) return
		val newtdg = tdg.makeNewTypeStructure(e => drclasses.contains(e.getTarget.value))
		println("=== " + tdg.edges.length +  " => " + newtdg.edges.length + " : " + (tdg.edges.length - newtdg.edges.length))
		makeModuleStructures(newtdg, "RuleNode_")
	}
	
	def getInterfaceClasses(mn: ModuleNode) : List[TypeNode] = {
		var interfaceClasses = List[TypeNode]()
		mn.inedges.
			filter(_.getSource.asInstanceOf[ModuleNode].packageName != mn.asInstanceOf[ModuleNode].packageName).
			foreach(e => {
				interfaceClasses = e.asInstanceOf[ModuleEdge].
					getTypeEdges.map(_.getTarget.asInstanceOf[TypeNode]) ::: interfaceClasses
				
			})
		interfaceClasses
	}
	
	def getInterfaceClasses(ms: ModuleStructure): Map[ModuleNode, List[TypeNode]] = {
		var result = Map[ModuleNode, List[TypeNode]] ()
		ms.nodes.values.foreach( mn => {
			val interfaceClasses = getInterfaceClasses(mn.asInstanceOf[ModuleNode])
			if ( interfaceClasses.length > 0 )
				result += ( mn.asInstanceOf[ModuleNode] -> interfaceClasses.removeDuplicates )
		})
		result
	}
	
	def layerInformation(lps: LayeredPackageStructure) = {
		println("----------------")
		lps.nodes.values.toList.sort((n1, n2) => n1.toString.compareTo(n2.toString) < 0).foreach( n => { 
			print("** " + n.toString + ": ")
			println(n.asInstanceOf[LayerModuleNode].types.sort((t1, t2) => t1.value.compareTo(t2.value) < 0 ).
					map(t => t.value.substring(t.value.lastIndexOf(".") + 1)).mkString(", "))
		} )
		println("----------------")
		/*print interface classes of lpdg, the meaning of each lp module is determined by interface classes ignoring internal classes
		inter package dependency only */
		val m2interfaceTypes = getInterfaceClasses(lps)
		m2interfaceTypes.foreach(m2i => {
			val prefix = m2i._1.packageName
			println(m2i._1.value + "'s interface classes (" + m2i._2.length + ") are\n" + 
					m2i._2.map(t => t.value.substring(if (t.value.length > prefix.length) prefix.length + 1 else 0)).mkString(","))
		})
		println("----------------")
		
	}
	
		
	protected def directCycles(from: NodeElem): List[NodeElem] = {
		val tos = from.outedges.map(_.getTarget)
		tos.foldLeft(List[NodeElem]())((ns, to) => if ( to.outedges.map(_.getTarget).contains(from)) to :: ns else ns )
	}
	
	protected 	def directCycles(dg: DependencyGraph): List[(NodeElem, NodeElem)] = {
		var result = List[(NodeElem, NodeElem)]()
		dg.nodes.values.foreach( n => { 
			directCycles(n).foreach(to => result = (n, to) :: result)
		})
		result
	}
	
	def architectureMetrics(tdg: TypeStructure, orgpdg: PackageStructure, pdg: PackageStructure, lpdg: LayeredPackageStructure, 
			newpdg: PackageStructure, clpdg: LayeredPackageStructure) = {
		println("-------------")
		println("*** Type dependency metrics")
		val tm = new TypeDepMetrics(tdg)
		println(tm.toString)

		println("*** Package dependency metrics - original")
		val opm = new ModuleDepMetrics(orgpdg)
		println(opm)
		
		println("*** Package dependency metrics")
		val pm = new ModuleDepMetrics(pdg)
		println(pm)

		println("*** Layered Package Module dependency metrics")
		val lpm = new ModuleDepMetrics(lpdg)
		println(lpm)
		
		println("*** New Package  dependency metrics")
		val npm = new ModuleDepMetrics(newpdg)
		println(npm)
		
		println("*** Compacted Layered Package Module  dependency metrics")
		val clpm = new ModuleDepMetrics(clpdg)
		println(clpm)
		
		println("-------------")
	}
	
	def makeNewPackageStructure(origpdg: PackageStructure, lpdg: LayeredPackageStructure): PackageStructure = {
		val newpkgs = getNewPacakgeMap
		//if ( newpkgs.size == 0 ) return null
		def newPackageKey(pkg: String, layers: List[Int]) = pkg + ":" + layers.mkString(",")
		val filtermap = getRefactoredEdges.map( entry => 
				((getLongPackageName(entry._1._1), getLongPackageName(entry._1._2)), entry._2 ))
		
		
		val newtdg = if ( getRefactoredEdges.size > 0 ) {
			def isRefactoredModuleEdges(e: DepEdge): Boolean = {
				val src = e.getSource.asInstanceOf[LayerModuleNode]
				val dst = e.getTarget.asInstanceOf[LayerModuleNode]
				val key = (src.packageName, dst.packageName)
				if (! filtermap.contains(key) ) return false
				val refactorPair = filtermap(key) // (List[Int], List[Int])
				if ( (refactorPair._1.head == -1 || refactorPair._1.contains(src.rank)) && 
						(refactorPair._2.head == -1|| refactorPair._2.contains(dst.rank))) {
					println("FILTERED: " + e)
					true			
				}
				else false
			}
			val refEdges = lpdg.edges.filter( e => isRefactoredModuleEdges(e)).flatMap(_.asInstanceOf[ModuleEdge].getTypeEdges)
			println("FILTERED edges: " + refEdges.size + "\n" + refEdges.mkString("\n"))
			println("FILTERED nodes: " + refEdges.map(_.getTarget).removeDuplicates.size + "\n" + 
					refEdges.map(_.getTarget).removeDuplicates.mkString("\n") )
					
			println("FILTERED nodes (source): " + refEdges.map(_.getSource).removeDuplicates.size + "\n" + 
					refEdges.map(_.getSource).removeDuplicates.mkString("\n") )
			lpdg.tdg.makeNewTypeStructure(e => refEdges.contains(e))
		} 
		else lpdg.tdg
		
		
		val newpdg = new PackageStructure(newtdg)
		
		def getTypeNodes(lnode: ModuleNode): List[TypeNode] = {
			lnode.types.map(n => newtdg.getNode(n.value).asInstanceOf[TypeNode])
		}
		
		origpdg.nodes.values.foreach(n => {
			val pn = n.asInstanceOf[ModuleNode]
			if ( newpkgs.contains(getShortPackageName(pn.packageName))) {
				val layers = newpkgs(getShortPackageName(pn.packageName))
				layers.foreach( ln => {
					var lnodes = ln.map(number => lpdg.nodes(lpdg.moduleKey(pn.packageName, number)))
					val newpn = newpdg.addNode(newPackageKey( pn.packageName, ln ))
					newpdg.addTypeNodes(newpn, lnodes.flatMap(lnode => getTypeNodes(lnode.asInstanceOf[ModuleNode])))	
				})
			}
			else {
				val newpn = newpdg.addNode(pn.packageName)
				val lnodes = lpdg.nodes.values.filter(_.asInstanceOf[ModuleNode].packageName == pn.packageName).toList
				newpdg.addTypeNodes(newpn, lnodes.flatMap(lnode => getTypeNodes(lnode.asInstanceOf[ModuleNode])))
			}
		})
		newpdg.liftEdges
		val scc =newpdg.detectSCC
		println("SCC in new PDS : " + scc.size + "\n" + scc.mkString("\n"))
		newpdg
	}
	
}