package module;


class LayerModuleNode(qn: String, r: Int, pkg: String) extends ModuleNode(qn ) {
	pkgname = pkg
	
	val rank = r
	var modules: List[LayerModuleNode] = this :: Nil
	def clients = inedges.map(_.getSource.asInstanceOf[LayerModuleNode])
    def dependents = outedges.map(_.getTarget.asInstanceOf[LayerModuleNode])
    def cloneNew =  { 
		var cloned = new LayerModuleNode(value, rank, pkgname)
		cloned.types = types
		cloned
	}
	override def toDot = {
		def suffixes = modules.remove(_ == this).sort(_.rank < _.rank).map(m => (if (m.pkgname.startsWith(pkgname) ) m.toString.substring(pkgname.length+1) else m.toString))
		if (suffixes.length > 0) toString + "\\n" + suffixes.mkString(",") else toString
	}
	

	
}

class LayeredPackageStructure(g: TypeStructure) extends ModuleStructure(g) {
	def moduleKey(p: String, r: Int) = p + ":" + r

	class LevelNode (n: NodeElem, scc: List[NodeElem]) {
		   var rank = 0
		   val node = n
		   val sccnodes = scc
		   var inedges: List[DepEdge] = Nil
		
		   if ( sccnodes == null ) inedges = node.inedges
		   else { // when scc nodes, remove intra edges in scc
			   for ( e <- node.inedges)
			     if ( !sccnodes.contains(e.getSource) ) 
			    	 inedges = e :: inedges
			}
		
		   def setRank(r: Int, n2ln: Map[NodeElem, LevelNode]) : List[LevelNode] = {
		     this.rank = r
		     if (sccnodes != null ) {
		       val sccln = sccnodes map (n2ln(_))
		       for ( ln <- sccln ) ln.rank = r
		       sccln
		     }
		     else this :: Nil 
		   }
		   
		   override def  toString = n.value + "(" + rank + ")"
	  }
 
	 def addNode(mvalue: String, r: Int, pkg: String, ms: List[LayerModuleNode]) = {
		 if ( !nodes.contains(mvalue) ) {
			 val lpnode = new LayerModuleNode(mvalue, r, pkg)
			 if ( !lpnode.modules.contains(ms) ) lpnode.modules = ms ::: lpnode.modules
    
			 nodes = Map(mvalue -> lpnode) ++ nodes
			 for ( t <- ms.flatMap(_.types) ) addTypeNode(lpnode, t.value)
		 }
		 nodes(mvalue).asInstanceOf[LayerModuleNode]
	}
 
	 def layeringTypes () : List[LevelNode] = {
		 val lscc = tdg.detectSCC()
		 
		 println("---------------- Detect SCC in Layering" )
		 println("#of SCC - " + lscc.size)
		 lscc.foreach(scc => println(scc.size + " - " + scc))
		 print("mean of class size in SCC - ") 
		 println((lscc.foldLeft(0)((count, scc) => count + scc.size)).asInstanceOf[Double]/lscc.size.asInstanceOf[Double])
		 println("----------------")

		 // if level of a class is modified & the class is in SCC, all of the classes in SCC are modified also. level propagation 
		 var n2ln : Map[NodeElem, LevelNode] = Map()
		 for ( scc <- lscc ) 
			 for ( n <- scc )
				 n2ln += n -> new LevelNode(n, scc)
	
		 for ( n <-  tdg.nodes.values )
			 if ( !n2ln.contains(n) ) 
				 n2ln += n -> new LevelNode(n, null)
	    
		 var worklist = n2ln.values.toList  // List[LayerNode]
		 while (!worklist.isEmpty) {
			 var changed : List[LevelNode] = Nil
			 for ( work <- worklist ) { 
				 for (edge <- work.inedges ) {
					 var from = n2ln(edge.getSource)      
					 if ( edge.isSubtypeEdge ) {
						 if ( from.rank < (work.rank + 1) )
							 changed = from.setRank(work.rank + 1, n2ln) ::: changed
					 }
					 else if ( edge.isInstanceOf[SimpleEdge] ) {
						 if ( from.rank < work.rank )
							 changed = from.setRank(work.rank, n2ln) ::: changed
					 }
				 }
			 }
			 worklist = changed
		 }
		 n2ln.values.toList
	}
 
 
	def layeringPackages( pdg: PackageStructure) = {
		val lnlist = layeringTypes()
	  
		def getModule(key: String, r: Int, pkg: String) : ModuleNode = {
				if ( !nodes.contains(key) ) nodes += key -> new LayerModuleNode(key, r, pkg)
				nodes(key).asInstanceOf[LayerModuleNode]
		}
		for ( ln <- lnlist ) {
			val node = ln.node.asInstanceOf[TypeNode]
            val pkgname = pdg.mapT2M(node).value
            var module = getModule(moduleKey(pkgname, ln.rank), ln.rank, pkgname)
            
            addTypeNode(module, node.value)
            node.rank = ln.rank
		}
	}
 
	def layeringPackagesWithSccs(pdg: PackageStructure) = {
		val lnlist = layeringTypes()
		def getModule(ln: LevelNode) :ModuleNode = {
			if ( ln.sccnodes == null ) {
					val node = ln.node.asInstanceOf[TypeNode]		
					val pkg = pdg.mapT2M(node).value
					val key = moduleKey(pkg, ln.rank)
					if ( !nodes.contains(key) ) {
							nodes += key -> new LayerModuleNode(key, ln.rank, pkg)
					}
					nodes(key).asInstanceOf[LayerModuleNode]
			}
		    else { // sccnodes => a separate module
		    	val pkg = ln.sccnodes.map(nodeelem => pdg.mapT2M(nodeelem.asInstanceOf[TypeNode]).value).removeDuplicates.mkString("-")
		    	val key = moduleKey(pkg, ln.rank)
		    	if ( !nodes.contains(key) ) nodes += key -> new LayerModuleNode(key, ln.rank, pkg)
		    	nodes(key).asInstanceOf[LayerModuleNode] 
		    }
		}
		
		for ( ln <- lnlist ) {
			val node = ln.node.asInstanceOf[TypeNode]		
            val module = getModule(ln)
            addTypeNode(module, node.value)
		}
	}
 

	//-----------------
	def getSortedPackageModuleMap(sortftn: (LayerModuleNode, LayerModuleNode) => Boolean) : Map[String, List[LayerModuleNode]] = {
			val lnodes = nodes.values.toList map (_.asInstanceOf[LayerModuleNode])
			val packages = lnodes.map(_.pkgname).removeDuplicates

			var mbps : Map[String, List[LayerModuleNode]] = Map();
			packages.foreach(p => (mbps += (p -> List[LayerModuleNode]())))
			mbps = lnodes.foldLeft(mbps) ((ms, n) => (ms + (n.pkgname ->( n :: ms(n.pkgname)))))

			var mbpssorted : Map[String, List[LayerModuleNode]] = Map()
			for  (mk <- mbps.keys ) {
				mbpssorted += (mk -> (mbps(mk).sort(sortftn)))
			}
			mbpssorted
	}

	def newLayeredPackageStructure(m2remove: List[LayerModuleNode], m2add: List[LayerModuleNode]) : LayeredPackageStructure = {
			var newLPS = new LayeredPackageStructure(tdg)
			for (n <- nodes.values.toList.map(_.asInstanceOf[LayerModuleNode]) ) {
				if ( !m2remove.contains(n) ) {
					var newn = n.cloneNew
					newLPS.addTypeNodes(newn, n.types)
					newLPS.nodes += (newn.value -> newn)
				}
			}
			for ( m <- m2add )  { 
				newLPS.nodes += (m.value -> m)
				newLPS.addTypeNodes(m, m.types)
			}

			newLPS.liftEdges
			newLPS
	}

	def getClientsOf(m: LayerModuleNode) = m.inedges.map(_.getSource.asInstanceOf[LayerModuleNode]).filter( _ != m )
	def getDependentsOf(m: LayerModuleNode) = (m.outedges.map(_.getTarget.asInstanceOf[LayerModuleNode])).filter( (dep) => (dep != m ))
	def isAPI(m: LayerModuleNode) = getClientsOf(m).exists(_.pkgname != m.pkgname) //if there exist incoming edges from the other modules


	private def fallthrough(m: LayerModuleNode, m1: LayerModuleNode) : Boolean = {
			if ( isAPI(m) )return false //if there exist incoming edges from the other modules
			if ( getDependentsOf(m).exists(_.rank > m1.rank) ) return false
			true
	}


	private def isIceburg(m: LayerModuleNode, m1: LayerModuleNode) : Boolean = {
			if (isAPI(m)) return false
			if ( getClientsOf(m).exists(m2 => (m2.pkgname == m.pkgname && m2.rank < m1.rank && !isIceburg(m1, m2))))  return false

			true
	}
	// -----------------------
	def mergeIceburgs: LayeredPackageStructure = {
			var mbpssorted = getSortedPackageModuleMap((m1, m2) => m1.rank < m2.rank)

			var result: Map[String, List[(LayerModuleNode, LayerModuleNode)]] = Map()
			for (lstm <- mbpssorted.values ) {
				if ( lstm.length > 1 ) {
					val r1 =  isIceburg(lstm.head, lstm.tail)
					if ( r1.length > 0 )  result += (lstm(0).pkgname ->r1 )
				}
			}

			var (m2remove, m2add ) = mergeModules(result.values.toList, ((m1, m2) => m1.rank < m2.rank))
			newLayeredPackageStructure(m2remove, m2add)
	}

	private def isIceburg(m: LayerModuleNode, tails: List[LayerModuleNode]) : List[(LayerModuleNode, LayerModuleNode)]= {
			if ( tails == Nil ) return Nil
			var result: List[(LayerModuleNode, LayerModuleNode)] = Nil
			for ( m1 <- tails) {
				if (isIceburg(m, m1)) {
					result = (m, m1) :: result
				}
			}
			result ::: isIceburg(tails.head, tails.tail)
	}


	// -----------------------

	def mergeFallthrough() : LayeredPackageStructure ={
			var mbps = getSortedPackageModuleMap((m1, m2) => m1.rank > m2.rank ) //decreasing order
			var result: Map[String, List[(LayerModuleNode, LayerModuleNode)]] = Map()
			for ( m2m <- mbps.values) {
				if (m2m.length > 1) { // when more than one moduel per pakcage
					val r1 = fallthrough(m2m.head, m2m.tail)
					if ( r1.length > 0 ) result += (m2m(0).pkgname -> r1)
				}
			}
			println("ft : " + result.values.toList)
			var (m2remove, m2add ) = mergeModules(result.values.toList, ((m1, m2) => m1.rank > m2.rank))
			println("ft r: " + m2remove +", ft a:" + m2add)

			newLayeredPackageStructure(m2remove, m2add)
	}

	private def fallthrough(m: LayerModuleNode, tails: List[LayerModuleNode]) : List[(LayerModuleNode, LayerModuleNode)]= {
			if ( tails == Nil ) return Nil
			var result: List[(LayerModuleNode, LayerModuleNode)] = Nil
			for ( m1 <- tails) {
				if (fallthrough(m, m1)) {
					result = (m, m1) :: result
				}
			}

			result ::: fallthrough(tails.head, tails.tail)
	}


	// -----------------------    
	private def mergeModules(llm: List[List[(LayerModuleNode, LayerModuleNode)]], 
			sortftn: ((LayerModuleNode, LayerModuleNode) => Boolean)) = {
		var m2remove: List[LayerModuleNode] = Nil
		var m2add:  List[LayerModuleNode] = Nil

		for ( lm <- llm) {
			var lowers: List[LayerModuleNode] = Nil
			var mergesTo: Map[LayerModuleNode, List[ModuleNode]] = Map()

			((lm.map(_._1) ::: lm.map(_._2)).removeDuplicates).foreach(m => (mergesTo += (m -> List[ModuleNode]())))
			mergesTo = lm.foldLeft(mergesTo)((mts, m) => (mts + (m._1 -> (m._2 :: mts(m._1)))))

			var ns: List[LayerModuleNode] = Nil
			ns = ((lm.foldLeft(ns)((l, m) => m._1 :: (m._2 :: l))).removeDuplicates).sort(sortftn) // ((m1, m2) => m1.rank < m2.rank)

			var merged: List[LayerModuleNode] = Nil
			var result: List[List[LayerModuleNode]] = Nil

			for ( n <- ns ) {
				if ( merged == Nil ) merged = n :: merged
				else {
					if ( merged.forall( mergesTo(_).contains(n))) merged = n :: merged
					else {
						result = merged :: result
						merged = Nil
					}
				}
			}
			if ( merged != Nil ) result = merged :: result

			println("**" + result)
			for ( r <- result ) {
				if ( r.length > 0 ) {
					var mr = merges(r, sortftn)
					m2remove = mr._1 ::: m2remove
					m2add = mr._2 :: m2add
				}
			}
		}
	(m2remove, m2add)
	}

	private def merges(ms: List[LayerModuleNode], sortftn: ((LayerModuleNode, LayerModuleNode) => Boolean)) : (List[LayerModuleNode], LayerModuleNode)= {
		val pkg = ms.head.pkgname
		var rank = ms.sort((sortftn)).reverse.head.rank
		println("min, max: " + rank + ": " + ms.sort(sortftn))
		var ltypes: List[TypeNode] = Nil
		var ms2remove: List[LayerModuleNode] =Nil
		for (m <- ms ) {
			ltypes = m.types ::: ltypes
			ms2remove = m :: ms2remove
		}

		var newnode = new LayerModuleNode(moduleKey(pkg, rank), rank, pkg)
		newnode.types = ltypes

		(ms2remove, newnode)
	}

}





