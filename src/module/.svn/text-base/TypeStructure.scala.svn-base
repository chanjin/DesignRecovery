package module

class TypeNode(qn: String) extends NodeElem(qn) {
	var rank = -1
	override def toDot = value + ( if (rank > -1) "(" + rank + ")" else "")
}

object TypeDepKind extends Enumeration {
	type TypeDepKind = Value
    val ParentDep, SimpleDep, CodeDep, OverridingDep = Value
    
    def kindFromStr(s: String) = s match {
		case "P" => TypeDepKind.ParentDep 
		case "S" => TypeDepKind.SimpleDep 
		case "C" => TypeDepKind.CodeDep 
		case "O" => TypeDepKind.OverridingDep 
	}
	
	def getDepCode(kind: TypeDepKind) = kind match {
		case TypeDepKind.ParentDep => "P"
		case TypeDepKind.SimpleDep => "S"
		case TypeDepKind.CodeDep  => "C"
		case TypeDepKind.OverridingDep  => "O"
	}
}

import TypeDepKind._

class SimpleEdge  (n1: NodeElem, n2: NodeElem, kind: TypeDepKind) extends DepEdge(n1, n2) {
	var kinds = List[TypeDepKind]()
	addKind(kind)
	
	def addKind(k: TypeDepKind) = {
		if (!kinds .contains(k)) // || !(kinds.contains(TypeDepKind.OverridingDep ) && k == TypeDepKind.ParentDep)) 
			kinds = k :: kinds
		//if ( k == TypeDepKind.OverridingDep ) kinds = kinds.remove(_ == ParentDep)
	}
	def addKinds(ks: List[TypeDepKind]) = ks.foreach(k => if(!kinds.contains(k)) addKind(k))
	def getKinds:  List[TypeDepKind] = kinds
	def getDepCode = kinds.map( k => TypeDepKind.getDepCode(k)).mkString(",")
	def isKindOf(k: TypeDepKind) = kinds.contains(k)
	override def isSubtypeEdge = kinds.contains(TypeDepKind.OverridingDep )
	override def toDot = getDepCode
}

class SubtypeEdge (n1: NodeElem, n2: NodeElem, ms: List[String]) extends  SimpleEdge(n1, n2, TypeDepKind.OverridingDep ) {
	def getMethods = ms
	//override def toDot = super.toDot //+ ": " + ms.mkString(",")
}

class TypeStructure extends DependencyGraph {
	def addNode(value: String): TypeNode = {
		val tn: TypeNode = new TypeNode(value) 
		nodes = Map(value -> tn) ++ nodes
		tn
	}
	
	def addNode(tn: TypeNode): TypeNode = {
		nodes = Map(tn.value -> tn) ++ nodes
		tn
	}
	
	def addSimpleEdge(n1: String, n2: String, kind: TypeDepKind): SimpleEdge = {
		//println("ADDSimple: " + n1 + ", " + n2 + ": " + kind)
		if ( n1 == n2 ) return null
		var e = getEdge(n1, n2).asInstanceOf[SimpleEdge]
		if ( e == null ) { 
			e = new SimpleEdge(nodes(n1).asInstanceOf[TypeNode], nodes(n2).asInstanceOf[TypeNode], kind)
			addEdge(e)
		}
		else 
			e.asInstanceOf[SimpleEdge].addKind(kind)
		e
	}
	
	def addSubtypeEdge(n1: String, n2: String, ms: List[String]): SimpleEdge = {
		//println("Subtype: " + n1 + ", " + n2 + ": " + ms)
		assert(n1 != n2)
		var e = getEdge(n1, n2).asInstanceOf[SimpleEdge]
		if (e == null || !e.isSubtypeEdge) {
			if ( e != null ) removeEdge(e)
			val ne = new SubtypeEdge(nodes(n1).asInstanceOf[TypeNode], nodes(n2).asInstanceOf[TypeNode], ms)
			if ( e != null ) ne.addKinds(e.getKinds)
			addEdge(ne)
			e = ne
		}
		else {
			e.asInstanceOf[SimpleEdge].addKind(TypeDepKind.OverridingDep )
		}
	    e
	}

 	
 	def inherits(subclass: String, superclass: String) : Boolean = {
 		def getAncestors(cls: TypeNode) : List[TypeNode] = {
 			val parent = cls.outedges.filter(e => {
 				if ( e.isInstanceOf[SimpleEdge] ) {
 					val se = e.asInstanceOf[SimpleEdge]
 					se.getKinds.exists(k => k == TypeDepKind.ParentDep || k == TypeDepKind.OverridingDep )
 				}
 				else false 
 			}).map(_.getTarget)

 			if ( parent.length == 0 ) {
 				return List[TypeNode]()
 			}
 			else {
 				parent.map(_.asInstanceOf[TypeNode]) ::: parent.flatMap(p => getAncestors(p.asInstanceOf[TypeNode]))
 			}
 		}
 		
 		val ancestors = getAncestors(nodes(subclass).asInstanceOf[TypeNode])
 		//println("anc of " + subclass + " - " + ancestors)
 		ancestors.contains(nodes(superclass))
 	}
 	
 	def getChild(parent: String) : String = {
 		val childedges = nodes(parent).inedges.filter(e => { 
 			val edge = e.asInstanceOf[SimpleEdge]
 			edge.getKinds.exists(_ == TypeDepKind.ParentDep )
 		})
 		if ( childedges.length == 0 ) return null
 		else {
 			childedges.head.getSource.value 
 		}
 	}
  	
 	private def addCloneEdge(tdg: TypeStructure, se: SimpleEdge) = {
		if ( se.isSubtypeEdge  ) {
			val edge = new SubtypeEdge(tdg.nodes(se.getSource.value), tdg.nodes(se.getTarget.value), se.asInstanceOf[SubtypeEdge].getMethods)
			edge.addKinds(se.getKinds)
			tdg.addEdge(edge)
		}
		else {
			val edge = new SimpleEdge(tdg.nodes(se.getSource.value), tdg.nodes(se.getTarget.value ), se.getKinds.head)
			edge.addKinds(se.getKinds.tail)
			tdg.addEdge(edge)
		}
 	}
 	
 	def makeNewTypeStructure(edgeFilter: DepEdge => Boolean) : TypeStructure = {
 		// edgeFilter's result is true => removed
 		var newts = new TypeStructure
 		nodes.values.foreach(node => newts.addNode(node.value).rank = node.asInstanceOf[TypeNode].rank)
 		edges.filter(e => !edgeFilter(e)).foreach(edge => addCloneEdge(newts, edge.asInstanceOf[SimpleEdge]))
 		newts
 	}
 	
 	private def getParents(tn: NodeElem, totn: NodeElem, prevList: List[NodeElem]) : List[NodeElem]  = {
 		if ( tn == totn ) return totn :: prevList
		
		val parentEdges = tn.outedges.filter(e => e.asInstanceOf[SimpleEdge].getKinds.contains(TypeDepKind.ParentDep))
		parentEdges.foreach(e => { 
				val result = getParents(e.getTarget, totn, e.getSource :: prevList)
				if ( result != null) return result
			}
		)
		null
	}
 	
 	def getParentList(tn: String, totn: String) : List[NodeElem] = {
 		if ( getNode(tn) == null || getNode(totn) == null ) return null
 		getParents(getNode(tn), getNode(totn), List[NodeElem]()).reverse
 	}

}
