package module

// for a given package, show subtype schema and using and subtyping structure

class LPSSubtypeStructure(pkg: String, lps: LayeredPackageStructure ) extends DependencyGraph {
	
	def dotname = pkg.replace(".", "_") + "_ST_tdg"
	
	def groupvalue(pkg: String, useorst: String) = pkg + useorst 
	
	abstract class STNode(pkg: String, v: String) extends NodeElem(v) {
		def pkgname = pkg
		def nodes: List[NodeElem]
	}
	class STEdge(from: NodeElem, to: NodeElem, isst: Boolean) extends DepEdge(from, to) {
		override def isSubtypeEdge = isst
	}
	
	
	class SubtypeAncestor(lm: LayerModuleNode, tn: NodeElem, v: String) extends STNode(lm.value, "S:" +v) {
		def nodes = List(tn)
	}
	
	
	class Group(pkg: String, tnodes: List[NodeElem], v: String) extends STNode(pkg, "C:" + v) {
		def nodes = tnodes
		override def toDot = {
			var dotstr = nodes.map(n => n.value.substring(n.value.lastIndexOf(".") + 1)).mkString(",")
			if (dotstr.length > 10) dotstr.substring(0, 10) + "..." + nodes.size
			else dotstr
		}
	}
	class UsingGroup(pkg: String,  tnodes: List[NodeElem]) 
		extends Group(pkg, tnodes, groupvalue(pkg, "USE")) {}
	class SubtypingGroup(pkg: String,  tnodes : List[NodeElem]) 
		extends Group(pkg, tnodes, groupvalue(pkg, "ST")) { }
	
	// -------------
	
	private def getModulesOfPackage(pkgname: String) : List[LayerModuleNode]= {
		lps.nodes.values.filter(m => (m.asInstanceOf[LayerModuleNode].pkgname == pkgname)).toList.
				map(_.asInstanceOf[LayerModuleNode]).sort((m1, m2) => m1.asInstanceOf[LayerModuleNode].rank > m2.asInstanceOf[LayerModuleNode].rank)
	}
	val lmspkg = getModulesOfPackage(pkg)
	
	val lmsall = ((lmspkg.foldLeft(List[NodeElem]())( (lms, lm) => 
							lm.outedges.map(_.getTarget) ::: lm.inedges.map(_.getSource) ::: lms)) ::: lmspkg ).removeDuplicates.
							map(_.asInstanceOf[LayerModuleNode])
	val st_ancestors =lmspkg.flatMap(_.types).filter(n => n.inedges.exists(_.isSubtypeEdge))
	
	val groups = st_ancestors.foldLeft(scala.collection.mutable.Map[(String, String), List[NodeElem]]())( (m, to) => {
		to.inedges.foreach(edge => {
			val from = edge.getSource.asInstanceOf[TypeNode]
			val pkg = lps.mapT2M(from).asInstanceOf[LayerModuleNode].pkgname
			if ( lmspkg.map(_.types).contains(from) || edge.isSubtypeEdge  ) {
				val key = if ( edge.isSubtypeEdge) (pkg, "ST") else (pkg, "USE")
				if ( !m.contains(key) ) m += (key -> List(from))
				else {
					if ( !m(key).contains(from)) m(key) = from :: m(key)
				}
			}
		})
		m
	})

	
	val mapT2M = scala.collection.mutable.Map[NodeElem, STNode]()
	var mapP2ST = scala.collection.mutable.Map[String, List[STNode]] ()
	
	def construct = {
		st_ancestors.foreach(n => {  
			val node = new SubtypeAncestor(lps.mapT2M(n.asInstanceOf[TypeNode]).asInstanceOf[LayerModuleNode], n, n.value)
			nodes = Map(node.value -> node) ++ nodes
			mapT2M += (n -> node)
		})
		println("--------")
		println(lmspkg.map(_.value).mkString(", "))
		println("# of st_ancestor: " + st_ancestors.size + " - " +lmspkg.flatMap(_.types).size)
		println(groups.size)
		
		
		groups.foreach( (kv) => {
			val (pkg, storuse) = kv._1
			val node = if ( storuse == "ST" ) new SubtypingGroup(pkg , kv._2) else new UsingGroup(pkg , kv._2)
			node.nodes.foreach(n => mapT2M += (n -> node))
			nodes = Map(node.value -> node) ++ nodes
		})
		
		def makeEdge(from: STNode, to: STNode) : DepEdge = {
			val isst = from.nodes.exists(n => n.outedges.exists(e =>to.nodes.contains(e.getTarget) && e.isSubtypeEdge ))
			new STEdge(from, to, isst)
		}
		
		
		nodes.values.foreach(n => { 
			val stn = n.asInstanceOf[STNode]
			var dsts = stn.nodes.flatMap(t => t.outedges.filter(e => mapT2M.contains(e.getTarget)).
					map(e => mapT2M(e.getTarget))).removeDuplicates
			
			if ( pkg != stn.pkgname) dsts = dsts.filter(dst => dst.pkgname == pkg)
			dsts.foreach(dst => addEdge(makeEdge(stn, dst)))
			
			
			if ( !mapP2ST.contains(stn.pkgname) ) mapP2ST += (stn.pkgname -> List(stn))
			else 
				mapP2ST(stn.pkgname) = stn :: mapP2ST(stn.pkgname) 
		} )
		
		println(nodes.size + ":" + lps.tdg.nodes.size)
	}
	
	def toDotTypeGrouped(dotfilename: String): Unit = {
		toDotTypeGrouped(mapP2ST, dotfilename)
	}
	
	def toDotTypeGrouped(mapM2N: scala.collection.mutable.Map[String, List[STNode]], dotfilename: String): Unit = {
		val dotname = 
			if ( dotfilename.indexOf("/") != -1) dotfilename.substring(dotfilename.lastIndexOf("/") + 1) else dotfilename
		var (node2id, count) = 
			nodes.values.foldLeft((scala.collection.mutable.Map[NodeElem, Int](), 0)) ((m, node) => ((m._1 + (node -> m._2)), m._2 + 1))
		def nodestrlist(stns: List[NodeElem]): List[String] = {
			stns.map(stn => node2id(stn) + "[ label=\"" + stn.toDot + "\"]")
		}
		def edgestr(e: DepEdge, node2id: NodeElem => Int) : String = 
			(node2id(e.getSource) + "->" + node2id(e.getTarget)) + 
			( if (e.isSubtypeEdge  )  Graph2Dot.edgeSubtype  else Graph2Dot.edgeSimple ) + "]" 
		
		 def moduleString(m2ts: (String, List[STNode]), count: Int) = 
			 "subgraph cluster" + count + 
		 		"	{  \n" + "node [shape=plaintext, fontname=Skia, fontsize=10];" + 
		 				"\nlabel=\"" + m2ts._1 + "\";\n" +  
		 				nodestrlist(m2ts._2).mkString(";\n") + ";\n"+ 
		 		"}\n"
	
		val nodeStrs = 
			mapM2N.foldLeft( (Nil: List[String], 0) ) ( ( liststr, m2ts) => (moduleString(m2ts, liststr._2) :: liststr._1,liststr._2 + 1))
		val edgeStrs = 
			edges.foldLeft(Nil: List[String]) ( (r, e) => edgestr(e, node2id) :: r )
	     
	    util.FileOut.saveFile(dotfilename + ".dot", 
	                   "digraph " + dotname + " { \n" 
	                   + "fontname=Skia; \nfontsize=9; \n"
	                   + Graph2Dot.edgestyle 
	                   + nodeStrs._1.mkString(" ")
	                   + edgeStrs.mkString(";\n") + "\n}")
	}
}

object LPSSubtypeStructure extends Application {
	val project = new projects.JHotdrawCase
	projects.Project.proj = project
	val prefix = project.prefix
	Graph2Dot.prefix = prefix
	import java.io.File
	if ( !(new File(project.getHomePath + "TypeStructure.lci")).exists ) {
		println("generate layer class information")
		(new constructor.DepGraphConstructor).loadGraph(projects.Project.get)
	}
	
	val dgs = constructor.GraphFile.load(projects.Project.proj.getHomePath + "TypeStructure.lci")
  	val pdg = dgs._2.simplifyStructure
  	val tdg = dgs._1
	val lpdg = new LayeredPackageStructure(tdg)
	lpdg.layeringPackages(pdg)
	lpdg.liftEdges()
	val lpsst = new LPSSubtypeStructure(prefix + ".util", lpdg)
	lpsst.construct
	//mapM2N
	lpsst.toDotTypeGrouped( projects.Project.proj.getHomePath + lpsst.dotname)
}